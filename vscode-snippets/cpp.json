{
	"Default CP Template": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define endl \"\\n\"",
			"#define ll long long",
			"#define watch(x) cout << #x << \" is \" << x << endl",
			"#define print(a, l, r) \\",
			"    for (int i = l; i < r; i++) cout << a[i] << (i == (r - 1) ? endl : \" \");",
			"const ll M = 1000000007;",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    cout.tie(NULL);",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "Default CP Template"
	},
	"power": {
		"prefix": "power",
		"body": [
			"ll power(ll x,ll y,ll M)",
		"{	",
			"",
		"	x=x%M;",
		"	ll ans=1;",
		"	while(y>0)",
		"	{",
		"		if(y%2!=0)",
		"			ans=mul(ans,x,M);",
		"			y/=2;",
		"			x=mul(x,x,M);",
		"	}",
		"	return ans%M;",
			"}"
		],
		"description": "Modular Exponentiation"
	},
	"add": {
		"prefix": "add",
		"body": [
			"ll add(ll x,ll y,ll M)",
			"{",
			"",
			"return ((x%M)+(y%M) + 2*M)%M;",
			"}"
		],
		"description": "Taking mod for addition"
	},
	"sub": {
		"prefix": "sub",
		"body": [
			"ll sub(ll x,ll y,ll M)",
			"{",
			"",
			"return ((x%M)-(y%M)+2*M)%M;",
			"}"
		],
		"description": "Taking mod for subtraction"
	},
	"mul": {
		"prefix": "mul",
		"body": [
			"ll mul(ll x,ll y,ll M)",
			"{",
			"",
			"return ((x%M)*(y%M))%M;",
			"}"
		],
		"description": "Taking mod for multiplication"
	},
	"inv": {
		"prefix": "inv",
		"body": [
			"ll inv(ll x,ll M)",
			"{",
			"",
			"return power(x,M-2,M);",
			"}"
		],
		"description": "MMI of x wrt prime M"
	},
	"matrixexpo": {
		"prefix": "matrixexpo",
		"body": [
			"typedef vector<vector<ll>> matrix;",
			"const int k = 2;",
			"",
			"matrix mul(matrix a, matrix b)",
			"{",
		"	matrix c(k + 1, vector<ll>(k + 1));",
		"	for (int i = 1; i <= k; i++)",
		"		for (int j = 1; j <= k; j++)",
		"			for (int l = 1; l <= k; l++)",
		"				c[i][j] = add(c[i][j],mul(a[i][l],b[l][j],M),M);",
		"	return c;",
			"}",
			"matrix pow(matrix a, ll p)",
			"{",
		"	if (p == 1)",
		"		return a;",
		"	if (p % 2)",
		"		return mul(a, pow(a, p - 1));",
		"	matrix ans = pow(a, p / 2);",
		"	return mul(ans, ans);",
			"}",
			"int fib(ll n)",
			"{",
			"",
		"	vector<ll>",
		"		f(k + 1);",
		"	f[1] = 1;",
		"	f[2] = 3;",
		"	matrix t(k + 1, vector<ll>(k + 1));",
		"	t[1][1] = 0, t[1][2] = 1;",
		"	t[2][1] = 2, t[2][2] = 2;",
			"",
		"	if (n == 1)",
		"		return 1;",
		"	t = pow(t, n - 1);",
			"",
		"	ll ans = 0;",
		"	for (int i = 1; i <= k; i++)",
		"		ans = add(ans,mul(t[1][i] ,f[i],M),M);",
		"	return ans;",
			"}",
			""
		],
		"description": "Matrix Exponentiation"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"vector<pair<ll,pair<ll,ll>>> g;",
			"ll parent[100010];",
			"ll s[100010];",
			"ll find(ll e)",
			"{",
		"	ll root=e;",
		"	while(root!=parent[root])",
		"	{",
		"		root=parent[root];",
		"	}",
		"	while(e!=root)",
		"	{",
		"		ll p=parent[e];",
		"		parent[e]=root;",
		"		e=p;",
		"	}",
		"	return root;",
			"}",
			"bool doUnion(ll a,ll b)",
			"{",
		"	ll roota=find(a);",
		"	ll rootb=find(b);",
		"	if(roota==rootb)",
		"		return false;",
		"	if(s[roota]<s[rootb])",
		"	{",
		"		parent[roota]=rootb;",
		"		s[rootb]++;",
		"	}",
		"	else",
		"	{",
		"		parent[rootb]=roota;",
		"		s[roota]++;",
		"	}",
		"	return true;",
		"}	",
			"ll kruskal()",
			"{",
			"    int x, y;",
			"    ll cost, minimumCost = 0;",
			"    for(int i = 0;i<g.size();++i)",
			"    {",
			"    ",
			"        x = g[i].second.first;",
			"        y = g[i].second.second;",
			"        cost = g[i].first;",
			"        if( doUnion(x, y))",
			"        {",
			"            minimumCost += cost;",
			"        }    ",
			"    }",
			"    return minimumCost;",
			"}"
		],
		"description": "Kruskals min cost"
	},
	"Dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"",
			"const ll N = 100010;",
			"ll parent[N];",
			"vector<vector<ll>> g[N];",
			"ll n, m;",
			"",
			"vector<ll> dijkstra() {",
			"    vector<ll> d(n, (ll)1e18);",
			"    vector<bool> visited(n, false);",
			"    d[0] = 0;",
			"    visited[0] = 0;",
			"    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;",
			"    parent[0] = -1;",
			"    pq.push({0, 0});",
			"    while (!pq.empty()) {",
			"        auto p = pq.top();",
			"        ll u = p.second;",
			"        ll du = p.first;",
			"        pq.pop();",
			"        visited[u] = true;",
			"        for (auto e : g[u]) {",
			"            if (!visited[e[0]]) {",
			"                if (d[e[0]] > du + e[1]) {",
			"                    d[e[0]] = du + e[1];",
			"                    pq.push({d[e[0]], e[0]});",
			"                    parent[e[0]] = u;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return d;",
			"}"
		],
		"description": "Dijkstra"
	},
	"KMP String Matching": {
		"prefix": "kmp",
		"body": [
			"void computeLPSArray(string pattern,int lps[])",
		  "	{	",
		  "		lps[1]=0;",
		  "		int k=0; ",
		  "		for(int i=2;i<pattern.length();i++)",
		  "		{",
		  "			while(k>0 && pattern[k+1]!=pattern[i])",
		  "				k=lps[k];",
			"",
		  "			if(pattern[k+1]==pattern[i])",
		  "				k++;",
			"",
		  "			lps[i]=k;",
		  "		}",
			"",
		  "	}",
		  "	int kmpMatching(string text,string pattern,int lps[])",
		  "	{	",
		  "		int prefix=0;",
		  "		int ans=-1;",
		  "		int k=0; ",
			"",
		  "		for(int i=1;i<text.length();i++)",
		  "		{",
		  "			while(k>0 && pattern[k+1]!=text[i])",
		  "				k=lps[k];",
		  "			",
			"            if(pattern[k+1]==text[i])",
			"            {",
			"                k++;",
			"            }",
			"            if(k==(pattern.length()-1))",
			"                k=lps[k];",
		  "		}",
		  "		return ((ans==-1)?0:ans);",
		  "	}"
		],
		"description": "KMP String Matching"
	},
	"Sieve": {
		"prefix": "sieve",
		"body": [
			"const int N = 1000010;",
			"int spf[N];",
			"",
			"void sieve() {",
			"    spf[1] = 1;",
			"    for (int i = 2; i < N; i++)",
			"        spf[i] = i;",
			"",
			"    for (int i = 4; i < N; i += 2)",
			"        spf[i] = 2;",
			"",
			"    for (int i = 3; i * i < N; i++) {",
			"        if (spf[i] == i) {",
			"            for (int j = i * i; j < N; j += i)",
			"                if (spf[j] == j)",
			"                    spf[j] = i;",
			"        }",
			"    }",
			"}"
		],
		"description": "Sieve"
	},
	"Tarjans SCC": {
		"prefix": "tarjan",
		"body": [
			"",
			"const ll N = 100010;",
			"vector<ll> g[N];",
			"ll ids[N], low[N], onStack[N], comp[N];",
			"//Initialize ids with -1",
			"ll id, sccCount;",
			"stack<ll> st;",
			"",
			"//Adapted from williamfiset/Algorithms",
			"void tarjan(ll at) {",
			"    st.push(at);",
			"    onStack[at] = true;",
			"    ids[at] = low[at] = id++;",
			"",
			"    for (auto to : g[at]) {",
			"        if (ids[to] == -1) {",
			"            tarjan(to);",
			"        }",
			"        if (onStack[to]) {",
			"            low[at] = min(low[at], low[to]);",
			"        }",
			"    }",
			"",
			"    // On recursive callback, if we're at the root node (start of SCC)",
			"    // empty the seen stack until back to root.",
			"    if (ids[at] == low[at]) {",
			"        sccCount++;",
			"        while (true) {",
			"            auto node = st.top();",
			"            st.pop();",
			"            onStack[node] = false;",
			"            low[node] = ids[at];",
			"            comp[node] = sccCount;",
			"            if (node == at) break;",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Tarjans SCC"
	},
	"nCr mod M": {
		"prefix": "nCr",
		"body": [
			"ll nCr(ll n, ll r, ll M) {",
			"    if (r == 0) {",
			"        return 1;",
			"    }",
			"    ll fact[n + 1];",
			"    fact[0] = 1;",
			"",
			"    for (ll i = 1; i <= n; i++) {",
			"        fact[i] = mul(fact[i - 1], i, M);",
			"    }",
			"",
			"    ll ans = mul(fact[n], inv(fact[r], M), M);",
			"    ans = mul(ans, inv(fact[n - r], M), M);",
			"    return ans;",
			"}"
		],
		"description": "nCr mod M"
	}
}